<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Que-sais je?]]></title>
  <link href="http://yenhuanli.github.io/atom.xml" rel="self"/>
  <link href="http://yenhuanli.github.io/"/>
  <updated>2017-04-13T21:31:56+02:00</updated>
  <id>http://yenhuanli.github.io/</id>
  <author>
    <name><![CDATA[yhli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Defensive Forecasting]]></title>
    <link href="http://yenhuanli.github.io/blog/2017/04/12/super-martingale/"/>
    <updated>2017-04-12T18:37:39+02:00</updated>
    <id>http://yenhuanli.github.io/blog/2017/04/12/super-martingale</id>
    <content type="html"><![CDATA[<p><em>Defensive forecasting</em> is an approach to designing competitive on-line learning algorithms. 
The ideas was partially motivated by the game-theoretic framework of probability theory.
Although it seems that finally, defensive forecasting can be formulated without stating game-theoretic probability as in <a href="https://doi.org/10.1016/j.tcs.2010.04.003">this paper</a>, I find it insightful to understand the original formulation.</p>

<h3 id="game-theoretic-probability">Game-Theoretic Probability</h3>

<p>To get some idea about what the game-theoretic framework is, let us review an interesting result in this framework. 
Consider the following probabiilty prediction game. 
Let $K_0 = 1$.
For every $n \in \mathbb{N}$,</p>

<ol>
  <li><em>Forecaster</em> announces $p_n \in [ 0, 1 ]$.</li>
  <li><em>Skeptic</em> announces $s_n \in \mathbb{R}$.</li>
  <li><em>Reality</em> announces $y_n \in \lbrace 0, 1 \rbrace$.</li>
  <li>$K_n = K_{n - 1} + s_n ( y_n - p_n )$.</li>
</ol>

<p>This is in fact a game of betting from the perspective of Skeptic: 
Initially Skeptic has $1$ dollar. 
If $s_n &gt; 0$, Skeptic is betting on the event $y_n = 1$; Skeptic gets $s_n y_n$ dollars in return if the event happens, and loses $s_n p_n$ dollars otherwise. 
Similarly, if $s_n &lt; 0$, Skeptic is betting against the event $y_n = 1$.</p>

<p>The sequence $(K_n)$ is called a <em>martingale</em>.
If $K_0 = 1$ and $K_n \geq 0$ for all $n$, the sequence $( K_n )$ is called a <em>scoring martingale</em>.</p>

<p>Of course, the values of $K_n$ depend on the strategy of Skeptic.
Roughly speaking, in the game-theoretic framework, an event of small probabiilty corresponds to a large value of $K_n$.</p>

<p><strong>Theorem.</strong>
(Weak law of large numbers) 
For any $N \in \mathbb{N}$, there exists a scoring martingale $( K_n )$, such that for any $\delta &gt; 0$, $K_N \geq 1 / \delta$ unless</p>

<script type="math/tex; mode=display">\left\vert \frac{\sum_{n = 1}^N ( y_n - p_n )}{N} \right\vert \leq \frac{1}{\sqrt{ \delta N }}.</script>

<p><em>Proof.</em> Choose</p>

<script type="math/tex; mode=display">s_n = \frac{2 \sum_{n = 1}^{n - 1} ( y_n - p_n )}{N}.</script>

<p><em>Q.E.D.</em></p>

<h3 id="defensive-forecasting">Defensive Forecasting</h3>

<p>Defensive forecasting aims at finding a strategy for Forecaster, such that Skeptic’s capital does not grow, no matter what Reality’s strategy is.</p>

<p>If Skeptic and Reality cooperate, this aim is in general impossible.
For example, Skeptic and Reality can choose $s_n$ and $y_n$ in the following way:</p>

<ul>
  <li>If $p_n &lt; 1 / 2$, they choose $s_n = 2$ and $y_n = 1$.</li>
  <li>If $p_n \geq 1 / 2$, they choose $s_n = -2$ and $y_n = 0$.</li>
</ul>

<p>Then $K_n \geq K_{n - 1} + 1$ for every $n$.</p>

<p>However, if we slightly weaken Skeptic, this aim becomes surprisingly easy.
Notice that Skeptic keeps his wealth growing, by setting $s_n$ as a discontinuous function of $p_n$.
Let us impose a restriction that $s_n$ must be a continuous function of $p_n$.
Then we arrive at the following defensive porecasting protocol.</p>

<p>Let $K_0 = 1$.
For every $n \in \mathbb{N}$,</p>

<ol>
  <li><em>Skeptic</em> announces a continuous function $s_n: [ 0, 1 ] \to \mathbb{R}$.</li>
  <li><em>Forecaster</em> announces $p_n \in [ 0, 1 ]$.</li>
  <li>Reality announces $y_n \in \lbrace 0, 1 \rbrace$.</li>
  <li>$K_n = K_{n - 1} + s_n ( p_n ) ( y_n - p_n )$.</li>
</ol>

<p><strong>Theorem.</strong> 
There always exists a strategy for Forecaster, such that $K_0 \geq K_1 \geq K_2 \geq \cdots$.</p>

<p><strong><em>Proof.</em></strong>
If $s_n$ is strictly positive on $[ 0, 1 ]$, choose $p_n = 1$. 
If $s_n$ is strictly negative on $[ 0, 1 ]$, choose $p_n = 0$.
Otherwise, by continuity of $s_n$, there must exist some $p^\star$ such that $s_n ( p^\star ) = 0$; choose $p_n = p^\star$.
<em>Q.E.D.</em></p>

<h3 id="k29">K29</h3>

<p>K29 is an algorithm for probability prediction, based on the defensive forecasting approach.
Consider the following protocol. 
For $n = 1, 2, \ldots, N$,</p>

<ol>
  <li>Forecaster announces $p_n \in [ 0, 1 ]$.</li>
  <li>Reality announces $y_n \in \lbrace 0, 1 \rbrace$.</li>
</ol>

<p>One can associate $y_n = 1$ to a rainy day; then $p_n$ dentoes Forecaster’s estimate of the probability that a rainy day will happend.</p>

<p>Let $\kappa$ be a kernel on $[ 0, 1 ]$.
The aim of K29 is to guarantee, for all $p \in [ 0, 1 ]$,</p>

<script type="math/tex; mode=display">\left\vert \sum_{n = 1}^N \kappa ( p_n, p ) ( y_n - p_n ) \right\vert \leq \sqrt{N} .</script>

<p>This inequality, roughly speaking, guarantees that the forecasting strategy is <em>calibrated</em>, i.e., for any $p \in [ 0, 1 ]$, among those days with $p_n \approx p$, there are about $( 100 \times p ) \%$ of them that are actually rainy. 
A precise intrepretation of the inequality is in fact much more complicated (for example, it is known that it is impossible to have a deterministic calibrated forecasting algorithm), and hence skipped due to my lazziness ;)
Please find the references for details.</p>

<p><strong>Theorem.</strong>
Assume $\kappa ( p, p ) \leq 1$ for all $p \in [ 0, 1 ]$.
The inequality above can be achieved, if Forecaster applies the defensive forecasting strategy with respect to</p>

<script type="math/tex; mode=display">s_n: p \mapsto \sum_{i = 1}^n \kappa ( p, p_i ) ( y_i - p_i ) .</script>

<h3 id="references">References</h3>

<ol>
  <li>G. Shafer and S. Ring, “Predicting bond yields using defensive forecasting,” 2010.</li>
  <li>V. Vovk, “Predictions as statements and decisions,” 2006.</li>
  <li>V. Vovk, A. Takemura, and G. Shafer, “Defensive forecasting,” 2005.</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hedge Algorithm (1/2)]]></title>
    <link href="http://yenhuanli.github.io/blog/2017/03/19/hedge/"/>
    <updated>2017-03-19T11:56:20+01:00</updated>
    <id>http://yenhuanli.github.io/blog/2017/03/19/hedge</id>
    <content type="html"><![CDATA[<p>Alice wants to win some money by betting on horce racing games. 
She knows nothing about horce racing. 
Fortunately, she knows that some of her friends are very good at betting on horce racing; however, she does not know who exactly is the best.
Suppose Alice will bet on several rounds sequentially.
Can Alice bet as well as the best among her friends <em>in the long run</em>?</p>

<p>Indeed, there are algorithms for doing so. 
A famous one is the so-called <em>hedge algorithm</em>, introduced in the paper <a href="http://dx.doi.org/10.1006/jcss.1997.1504">“A desicion-theoretic generalization of on-line learning and an application to boosting”</a> by Y. Freund and R. Schapire.</p>

<p>The idea is to switch between Alice’s fridends’ strategies. 
Assume for simplicity that Alice will always bet 1 unit of money for each round. 
Alice keeps in her mind a <em>weight</em> for each of her friend. 
At the beginning of each round, she chooses one of her friends with probability proportional to the weights, say Bob, and follows Bob’s bet. 
Once a round finishes, Alice sees how much she would lose had she followed any of her friend. 
She then updates the weights accordingly.
Those who yielded smaller losses have higher weights, and vice versa.</p>

<p>Let us formalize the idea. 
We label the rounds by positive integers $t \in \mathbb{N}$.
Suppse Alice has $N$ friends; let us index them by the set $[N] := \lbrace 1, \ldots, N \rbrace$.
We summarize the weights before the $t$-th round by a weight vector $w_t := ( w_t (i) )_{i \in [N]} \in \mathbb{R}^N$ in the probability simplex, where $w_t (i)$ denotes the weight assigned to Friend $i$.
We also summarize the losses yielded by each friend’s bet for the $t$-th round by a vector</p>

<script type="math/tex; mode=display">x_t := ( x_t (i) )_{i \in [N]} \in [ 0, + \infty [^N .</script>

<p>Then for the $t$-th round, the expected loss of Alice is</p>

<script type="math/tex; mode=display">\sum_{i \in [N] } x_t(i) w_t(i) := \langle x_t, w_t \rangle .</script>

<p>Suppose Alice will bet on $T$ rounds.
The goal of Alice is to have a small <em>regret</em></p>

<script type="math/tex; mode=display">R_T := \sum_{t \in [T]} \langle x_t, w_t \rangle - \min_{i \in [N]} \sum_{t \in [T]} x_t(i) ,</script>

<p>where $[T] := \lbrace 1, \ldots, T \rbrace$.</p>

<p>The regret measures the difference between Alice’s expected loss and the loss yielded by the best friend <em>in hindsight</em>.
If $R_T = o(T)$, in hindsight, the difference between the average expected losses of Alice and the best friend converges to zero. 
Notice that the <em>best friend</em> in general varies with $T$.</p>

<p>The hedge algorithm is a specific rule of setting the weights. 
Initially, Alice chooses any weight $w_1$ such that $w_1 (i) \neq 0$ for all $i$. 
After observing the losses $x_t$, Alice updates the weights as</p>

<script type="math/tex; mode=display">w_{t+1} (i) = Z_t^{-1} w_t(i) \, \mathrm{e}^{- \eta x_t (i)} , \quad i \in [N] ,</script>

<p>where $Z_t := \sum_{i \in [N]} w_t (i) \, \mathrm{e}^{- \eta x_t (i)}$ is the normalizing constant, and $\eta$ is a properly chosen <em>learning rate</em>.</p>

<p>The hedge algorithm looks similar to the aggregating algorithm (AA). 
Indeed, we can formulate the problem using the setting of prediction with expert advice (PEA). 
Let Alice be Learner and her friends be the experts.
Let Nature choose the loss vectors.
Set the outcome space $\Omega$ as $[ 0, + \infty [^N$, prediction space $\Gamma$ as the probability simplex in $\mathbb{R}^N$, and loss function as</p>

<script type="math/tex; mode=display">\lambda ( \omega, \gamma ) := \langle \omega, \gamma \rangle , \quad \omega \in \Omega, \gamma \in \Gamma.</script>

<p>When each expert $i \in [N]$ chooses a fixed prediction $\gamma_t (i) = ( \delta_{i,j} )_{j \in [N]} \in \mathbb{R}^N$, we recover the original betting-horce-racing-games problem.</p>

<p>However, applying the AA to this specific PEA game is not trivial, and requires some generalization of the mixability condition. 
We will see that the resulting algorithm yields $R_T = O ( \sqrt{T} )$, assuming bounded losses.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aggregating Algorithm]]></title>
    <link href="http://yenhuanli.github.io/blog/2017/03/02/aggregating-algorithm/"/>
    <updated>2017-03-02T18:57:06+01:00</updated>
    <id>http://yenhuanli.github.io/blog/2017/03/02/aggregating-algorithm</id>
    <content type="html"><![CDATA[<p>This post is essentially a summary of some results in the classical paper <a href="http://dx.doi.org/10.1006/jcss.1997.1556">“A game of prediction with expert advice”</a> by V. Vovk.</p>

<p><strong>Definition.</strong> A <em>game</em> is a triple $( \Omega, \Gamma, \lambda )$, where $\Omega$ is the <em>outcome space</em>, $\Gamma$ is the <em>prediction space</em>, and $\lambda: \Omega \times \Gamma \to [0, \infty]$ is the <em>loss function</em>.</p>

<p>Consider the standard <em>learning with expert advice</em> setting, in which a <em>learner</em> tries to predict the outcomes of the <em>nature</em> sequentially, with the help of $n$ <em>experts</em>. 
Precisely speaking, at each trial $t \in \mathbb{N}$:</p>

<ol>
  <li>Each expert $i$ makes a prediction $\gamma_t (i)$, $1 \leq i \leq n$.</li>
  <li>The learner makes a prediction $\gamma_t \in \Gamma$.</li>
  <li>The nature chooses an outcome $\omega_t \in \Omega$.</li>
  <li>The learner suffers for the loss $\lambda ( \omega_t, \gamma_t )$.</li>
</ol>

<p>Notice that before making his prediction at the trial $t$, the learner has access to the past history of the nature (up to trial $t - 1$) and all of the experts (up to trial $t$).</p>

<p>For every $t \in \mathbb{N}$, let us define the learner’s accumulative loss as</p>

<script type="math/tex; mode=display">L_t := \lambda( \omega_1, \gamma_1 ) + \cdots + \lambda ( \omega_t, \gamma_t ),</script>

<p>and each expert’s accumulative loss as</p>

<script type="math/tex; mode=display">L_t ( i ) := \lambda( \omega_1, \gamma_1 ( i ) ) + \cdots + \lambda( \omega_t, \gamma_t ( i ) ), \quad i = 1, \ldots, n .</script>

<p>The learner’s goal is to make predictions almost as well as the <em>best expert</em>, in the sense that $L_t \leq L_t(i) + \varepsilon$ for all $i \leq n$, $t \in \mathbb{N}$, and some <em>small enough</em> $\varepsilon$.</p>

<p><strong>Definition.</strong> We say the game is <em>$\eta$-mixable</em>, if for any probability distribution $P$ on $\Gamma$, there exists a $\gamma^\star \in \Gamma$, such that</p>

<script type="math/tex; mode=display">\exp ( - \eta \lambda ( \omega, \gamma^\star ) ) \geq \int \exp ( - \eta \lambda( \omega, \gamma ) ) \, P( \mathrm{d} \gamma ), \quad \text{for all } \omega \in \Omega . \notag</script>

<p><strong>Remark.</strong> By Jensen’s inequality, if the mapping $\gamma \mapsto \exp ( - \eta \lambda ( \omega, \gamma ) )$ is concave for all $\omega \in \Omega$, then the game is $\eta$-mixable.
Any such loss function $\lambda$ is called <em>exp-concave</em>. 
Obviously, one can simply choose $\gamma^\star = \int \gamma \, P ( \mathrm{d} \gamma )$ if the loss is exp-concave.</p>

<p><strong>Proposition.</strong> <em>If a game is $\eta$-mixable, there exists a prediction algorithm for the learner, such that</em></p>

<script type="math/tex; mode=display">L_t \leq L_t ( i ) + \eta^{-1} \ln n , \quad \text{for all } i \leq n .</script>

<p>One such algorithm is the <em>aggregating algorithm (AA)</em>, first introduced in the paper <a href="http://vovk.net/aa/index.html">“Aggregating strategies”</a> by V. Vovk.
Let $( \pi_0 ( i ) )_{i \leq n}$ be a probability vector whose entries are all non-zero. 
At each trial $t \in \mathbb{N}$, the AA outputs a prediction $\gamma_t \in \Gamma$ satisfying</p>

<script type="math/tex; mode=display">\exp ( - \eta \lambda ( \omega_t, \gamma_t ) ) \geq \sum_{i \leq n} \pi_{t - 1} ( i ) \exp ( - \eta \lambda( \omega_t, \gamma_t ( i ) ) ) ,</script>

<p>and after observing $\omega_t$, the AA updates the probability vector as</p>

<script type="math/tex; mode=display">\pi_t ( i ) := z_t^{-1} \pi_{t - 1} ( i ) \exp ( - \eta \, \lambda ( \omega_t, \gamma_t ( i ) ) ) , \quad \text{for all } i \leq n ,</script>

<p>where $z_t$ is a normalizing constant such that $( \pi_t (i) )_{i \leq n}$ is also a probability vector.
Because of the $\eta$-mixability assumption, the AA is well-defined.</p>

<p><strong>Lemma.</strong> For each $t \in \mathbb{N}$, one has</p>

<script type="math/tex; mode=display">\exp ( - \eta L_t ) \geq \sum_{i \leq n} \pi_0 ( i ) \, \exp ( - \eta L_t ( i ) ) .</script>

<p><strong>Proof.</strong> We prove by induction. 
Obviously, the inequality holds for $t = 0$ (for which we set $L_t = L_t (i) = 0$ for all $i \leq n$).
Assume the inequality to be proved holds for $t = T$.
We write</p>

<script type="math/tex; mode=display">\exp ( - \eta L_{T + 1} ) = \exp ( - \eta L_T ) \exp ( - \eta \lambda ( \omega_{T + 1}, \gamma_{T + 1}(i) ) )</script>

<p>By the definition of the AA, the RHS is bounded below by</p>

<script type="math/tex; mode=display">\exp ( - \eta L_T ) \frac{ \sum_{i \leq n} \exp ( - \eta \lambda ( \omega_{T+1}, \lambda_{T+1} ( i ) ) ) \, \pi_0 ( i ) \, \exp ( - \eta L_T ( i ) ) }{ \sum_{i \leq n} \pi_0 ( i ) \, \exp ( - \eta L_T ( i ) ) } .</script>

<p>By assumption, the RHS can be further bounded below by</p>

<script type="math/tex; mode=display">\sum_{i \leq n} \exp ( - \eta \lambda ( \omega_{T+1}, \lambda_{T+1} ( i ) ) ) \, \pi_0 ( i ) \, \exp ( - \eta L_{T} ( i ) ) = \sum_{i \leq n} \pi_0 ( i ) \exp ( \eta L_{T+1} ( i ) ) .</script>

<p>This proves the lemma. <em>Q.E.D.</em></p>

<p>By the lemma, we have</p>

<script type="math/tex; mode=display">\exp ( - \eta L_t ) \geq \pi_0 ( i ) \, \exp ( - \eta L_t ( i ) ) , \quad \text{for all } i \leq n .</script>

<p>Hence we obtain</p>

<script type="math/tex; mode=display">L_t \leq L_t ( i ) + \frac{1}{ \eta } \log \left( \frac{1}{ \pi_0 ( i ) } \right) , \quad \text{for all} i \leq n.</script>

<p>Choosing $\pi_0 ( i ) = 1 / n$ for all $i$ (the uniform distribution) proves the proposition.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Interesting Talks at NIPS 2016]]></title>
    <link href="http://yenhuanli.github.io/blog/2016/12/12/interesting-talks-in-nips-2016/"/>
    <updated>2016-12-12T22:57:59+01:00</updated>
    <id>http://yenhuanli.github.io/blog/2016/12/12/interesting-talks-in-nips-2016</id>
    <content type="html"><![CDATA[<p>NIPS 2016 was quite successful, in the sense that most of the papers interesting to me were chosen as oral presentations:)
The list below is of course non-exhaustive and biased.
The order is alphabetical, according to the last names of the presenters/first authors.</p>

<ul>
  <li>“Kernel-based Methods for Bandit Convex Optimization” by S. Bubeck
    <ul>
      <li>Bubeck wrote a blog article on this paper: <a href="https://blogs.princeton.edu/imabandit/2016/08/06/kernel-based-methods-for-bandit-convex-optimization-part-1/">part 1</a>, <a href="https://blogs.princeton.edu/imabandit/2016/08/09/kernel-based-methods-for-convex-bandits-part-2/">part 2</a>, and <a href="https://blogs.princeton.edu/imabandit/2016/08/10/kernel-based-methods-for-convex-bandits-part-3/">part 3</a>.</li>
      <li>Bubeck had given basically the same talk at the Simons Institute <a href="https://youtu.be/fV4qd43OsY8">(youtube video)</a>.</li>
    </ul>
  </li>
  <li><a href="http://papers.nips.cc/paper/6490-supervised-learning-through-the-lens-of-compression">“Supervised learning through the lens of compression”</a> by O. David, S. Moran, and A. Yehudayoff
    <ul>
      <li>Roughly speaking, a function class is learnable if it allows (approximate) compression. Notice that the <a href="https://users.soe.ucsc.edu/~manfred/pubs/T1.pdf">compression</a> is not defined in the Shannon-theoretic way.</li>
    </ul>
  </li>
  <li><a href="http://papers.nips.cc/paper/6467-generalization-of-erm-in-stochastic-convex-optimization-the-dimension-strikes-back">“Generalization of ERM in stochastic convex optimization: The dimension strikes back”</a> by V. Feldman
    <ul>
      <li>This paper shows that minimizing the empirical average is not an optimal strategy for stochastic approximation in general.</li>
    </ul>
  </li>
  <li>“Safe testing: An adaptive alternative to p-value-based testing” by P. Grunwald
    <ul>
      <li>Grunwald proposed the notion of safe test, which is robust against possible abuse of statistical methods, such as collecting data until the p-value is large enough. He also provided an algorithm for safe testing, based on the so-called reverse I-projection.</li>
      <li>Unfortunately, it seems that the paper has not been available on the internet.</li>
    </ul>
  </li>
  <li><a href="https://nips.cc/Conferences/2016/Schedule?showEvent=6206">“Theory and algorithms for forecasting non-stationary time series”</a> by V. Kuznetsov and M. Mohri
    <ul>
      <li>This is a tutorial talk mainly based on their <a href="http://papers.nips.cc/paper/5836-learning-theory-and-algorithms-for-forecasting-non-stationary-time-series">NIPS’15 paper</a> and <a href="http://www.jmlr.org/proceedings/papers/v49/kuznetsov16.html">COLT’16 paper</a>.</li>
    </ul>
  </li>
  <li><a href="http://papers.nips.cc/paper/6245-without-replacement-sampling-for-stochastic-gradient-methods">“Without-replacement sampling for stochastic gradient methods”</a> by O. Shamir
    <ul>
      <li>This paper provides convergence guarantees for the setting mentioned in its title.</li>
    </ul>
  </li>
  <li><a href="https://nips.cc/Conferences/2016/Schedule?showEvent=6200">“Stochastic optimization: Beyond stochastic gradients and convexity: Part 2”</a> by S. Sra
    <ul>
      <li>The <a href="http://suvrit.de/talks/vr_nips16_sra.pdf">slides</a> can serve as a good bibliography on solving non-convex finite-sum optimization problems.</li>
    </ul>
  </li>
  <li><a href="http://papers.nips.cc/paper/6268-metagrad-multiple-learning-rates-in-online-learning">“MetaGrad: Multiple learning rates in online learning”</a> by T. van Erven and W. M. Koolen
    <ul>
      <li>This paper proposes a somewhat universally optimal scheme for online learning. The idea is to discretize the interval of possible step sizes, treat each candidate step size as an expert, and then do prediction with experts to choose the step size.</li>
    </ul>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Pinching Trick and the Golden-Thompson Inequality]]></title>
    <link href="http://yenhuanli.github.io/blog/2016/11/10/the-pinching-trick-and-the-golden-thompson-inequality/"/>
    <updated>2016-11-10T11:10:24+01:00</updated>
    <id>http://yenhuanli.github.io/blog/2016/11/10/the-pinching-trick-and-the-golden-thompson-inequality</id>
    <content type="html"><![CDATA[<h3 id="pinching">Pinching</h3>

<p>Let $A$ be a Hermitian matrix, and $A = \sum_j \lambda_j P_j$ be the spectral decomposition of $A$. 
The <em>pinching map</em> defined by $A$ is given by</p>

<script type="math/tex; mode=display">\mathcal{P}_A (X) = \sum_j P_j X P_j ,</script>

<p>for any Hermitian matrix $X$.</p>

<p><strong>Theorem 1.</strong> Let $A$ be a positive semi-definite matrix and $B$ be a Hermitian matrix. 
The following statements hold.</p>

<ol>
  <li>$\mathcal{P}_B (A)$ commutes with $B$.</li>
  <li>$\mathrm{Tr} ( \mathcal{P}_B (A) B ) = \mathrm{Tr} ( A B )$.</li>
  <li><em>(Pinching inequality)</em> $\vert \mathrm{spec} (B) \vert \, \mathcal{P}_B (A) \geq A$, where $\mathrm{spec} (B)$ denotes the set of eigenvalues of $B$.</li>
</ol>

<p>The first two statements are easy to check.
The earliest reference on the pinching inequality I can find is the <a href="https://www.elsevier.com/books/von-neumann-algebras/dixmier/978-0-444-86308-9">classic book by Jacques Dixmier</a>.
A simple proof of the pinching inequality can be found in the <a href="http://www.springer.com/us/book/9783540302650">textbook by Masahito Hayashi</a>.</p>

<p>One main issue in matrix analysis is non-commutativity. 
The first statement in Theorem 1 hints that pinching can be an useful tool to deal with this issue. 
In the next section, the pinching trick is illustrated using the Golden-Thompson inequality as an example.</p>

<h3 id="a-proof-of-the-golden-thompson-inequality">A proof of the Golden-Thompson Inequality</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Golden%E2%80%93Thompson_inequality">Golden-Thompson inequality</a> says that</p>

<script type="math/tex; mode=display">\mathrm{Tr} ( \exp ( A + B ) ) \leq \mathrm{Tr} ( \exp (A) \exp (B) ) ,</script>

<p>for any two Hermitian matrices $A$ and $B$. 
Obviously, if $A$ commutes with $B$, the Golden-Thompson inequality holds with an equality; however, in general one needs to take non-commutativity into consideration.
Below we present a very elegant proof using the pinching trick from a <a href="https://arxiv.org/abs/1604.03023">recent paper by D. Sutter et al</a>.</p>

<p>The key observation is that $\vert \mathrm{spec} ( A^{\otimes n} ) \vert$ does not grow rapidly with $n$ for any Hermitian matrix $A$.</p>

<p><strong>Lemma 1.</strong> One has $\vert \mathrm{spec} ( A^{\otimes n} ) \vert = O ( \mathsf{poly} (n) )$ for any Hermitian matrix $A$.</p>

<p><em>Proof (Golden-Thompson inequality).</em></p>

<p>Let $X$ and $Y$ be two positive definite matrices. 
Then one can write</p>

<script type="math/tex; mode=display">\log \mathrm{Tr} ( \exp ( \log X + \log Y ) ) = \frac{1}{n} \log \mathrm{Tr} ( \exp ( \log X^{\otimes n} + \log Y^{\otimes n} ) ),</script>

<p>for any positive integer $n$. 
By the pinching inequality, one has</p>

<script type="math/tex; mode=display">\frac{1}{n} \log \mathrm{Tr} ( \exp ( \log X^{\otimes n} + \log Y^{\otimes n} ) ) \leq \frac{1}{n} \log \mathrm{Tr} \{ \exp [ \log ( \vert \mathrm{spec} ( Y^{\otimes n} ) \vert \, \mathcal{P}_{Y^{\otimes n}} ( X^{\otimes n} ) ] + \log Y^{\otimes n} ) \}</script>

<p>By the first two statements in Theorem 1 and Lemma 1, one has</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\text{RHS} & = \frac{1}{n} \log \mathrm{Tr}\, ( \mathcal{P}_{Y^{\otimes n}} ( X^{\otimes n} ) Y^{\otimes n} ) + \frac{\log \mathsf{poly} (n)}{n} \notag \\
& = \frac{1}{n} \log \mathrm{Tr} ( X^{\otimes n} Y^{\otimes n} ) + \frac{\log \mathsf{poly} (n)}{n} \notag \\
& = \log \mathrm{Tr}\, ( X Y ) + \frac{\log \mathsf{poly} (n)}{n} . 
\end{align} %]]&gt;</script>

<p>Then one obtains the Golden-Thompson Inequality by letting $n \to \infty$.</p>
]]></content>
  </entry>
  
</feed>
